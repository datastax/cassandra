--- a/src/java/org/apache/cassandra/db/compaction/Scrubber.java
+++ b/src/java/org/apache/cassandra/db/compaction/Scrubber.java
@@ -67,14 +67,6 @@
     private int badPartitions;
     private int emptyPartitions;
 
-<<<<<<<
-=======
-    private ByteBuffer currentIndexKey;
-    private ByteBuffer nextIndexKey;
-    private long currentPartitionPositionFromIndex;
-    private long nextPartitionPositionFromIndex;
-
->>>>>>>
     private NegativeLocalDeletionInfoMetrics negativeLocalDeletionInfoMetrics = new NegativeLocalDeletionInfoMetrics();
 
     private final OutputHandler outputHandler;
@@ -140,12 +132,6 @@
 
         this.scrubInfo = new ScrubInfo(dataFile, sstable, fileAccessLock.readLock());
 
-<<<<<<<
-=======
-        this.currentPartitionPositionFromIndex = 0;
-        this.nextPartitionPositionFromIndex = 0;
-
->>>>>>>
         if (reinsertOverflowedTTLRows)
             outputHandler.output("Starting scrub with reinsert overflowed TTL option");
     }
@@ -190,28 +176,7 @@
         try (SSTableRewriter writer = SSTableRewriter.construct(cfs, transaction, false, sstable.maxDataAge);
              Refs<SSTableReader> refs = Refs.ref(Collections.singleton(sstable)))
         {
-<<<<<<<
             assert !indexAvailable() || indexIterator.dataPosition() == 0 : indexIterator.dataPosition();
-=======
-            try
-            {
-                nextIndexKey = indexAvailable() ? ByteBufferUtil.readWithShortLength(indexFile) : null;
-                if (indexAvailable())
-                {
-                    // throw away variable so we don't have a side effect in the assert
-                    long firstRowPositionFromIndex = rowIndexEntrySerializer.deserializePositionAndSkip(indexFile);
-                    assert firstRowPositionFromIndex == 0 : firstRowPositionFromIndex;
-                }
-            }
-            catch (Throwable ex)
-            {
-                throwIfFatal(ex);
-                nextIndexKey = null;
-                nextPartitionPositionFromIndex = dataFile.length();
-                if (indexFile != null)
-                    indexFile.seek(indexFile.length());
-            }
->>>>>>>
 
             StatsMetadata metadata = sstable.getSSTableMetadata();
             writer.switchWriter(CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, metadata.repairedAt, metadata.pendingRepair, metadata.isTransient, sstable, transaction));
@@ -244,29 +209,13 @@
                 ByteBuffer currentIndexKey = indexIterator != null ? indexIterator.key() : null;
                 if (currentIndexKey != null)
                 {
-<<<<<<<
                     dataStartFromIndex = indexIterator.dataPosition() + TypeSizes.SHORT_SIZE + currentIndexKey.remaining();
                     if (advanceIndexNoThrow())
                         dataSizeFromIndex = indexIterator.dataPosition() - dataStartFromIndex;
                 }
 
-                // avoid an NPE if key is null
-                String keyName = key == null ? "(unreadable key)" : ByteBufferUtil.bytesToHex(key.getKey());
-                outputHandler.debug(String.format("row %s is %s", keyName, FBUtilities.prettyPrintMemory(dataSizeFromIndex)));
-
-=======
-                    if (currentIndexKey != null)
-                    {
-                        dataStartFromIndex = currentPartitionPositionFromIndex + 2 + currentIndexKey.remaining();
-                        dataSizeFromIndex = nextPartitionPositionFromIndex - dataStartFromIndex;
-                    }
-                }
-
-                long dataStart = dataFile.getFilePointer();
-
                 String keyName = key == null ? "(unreadable key)" : keyString(key);
                 outputHandler.debug(String.format("partition %s is %s", keyName, FBUtilities.prettyPrintMemory(dataSizeFromIndex)));
->>>>>>>
                 assert currentIndexKey != null || !indexAvailable();
 
                 try
@@ -281,19 +230,11 @@
                                 "_too big_", ByteBufferUtil.bytesToHex(currentIndexKey))));
                     }
 
-<<<<<<<
-                    if (indexFile != null && dataSizeFromIndex > dataFile.length())
-                        throw new IOError(new IOException("Impossible partition size (greater than file length): " + dataSizeFromIndex));
-
-                    if (indexFile != null && dataStart != dataStartFromIndex)
-                        outputHandler.warn(String.format("Data file partition position %d differs from index file row position %d", dataStart, dataStartFromIndex));
-=======
                     if (indexIterator != null && dataSizeFromIndex > dataFile.length())
-                        throw new IOError(new IOException("Impossible row size (greater than file length): " + dataSizeFromIndex));
+                        throw new IOError(new IOException("Impossible partition size (greater than file length): " + dataSizeFromIndex));
 
                     if (indexIterator != null && dataStart != dataStartFromIndex)
-                        outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex));
->>>>>>>
+                        outputHandler.warn(String.format("Data file partition position %d differs from index file row position %d", dataStart, dataStartFromIndex));
 
                     if (tryAppend(prevKey, key, writer))
                         prevKey = key;
@@ -430,35 +371,16 @@
 
     private boolean advanceIndexNoThrow()
     {
-<<<<<<<
-        currentIndexKey = nextIndexKey;
-        currentPartitionPositionFromIndex = nextPartitionPositionFromIndex;
-        try
-        {
-            nextIndexKey = !indexAvailable() ? null : ByteBufferUtil.readWithShortLength(indexFile);
-
-            nextPartitionPositionFromIndex = !indexAvailable()
-                                             ? dataFile.length()
-                                             : rowIndexEntrySerializer.deserializePositionAndSkip(indexFile);
-=======
         try
         {
             return indexAvailable() && indexIterator.advance();
->>>>>>>
         }
         catch (Throwable th)
         {
             JVMStabilityInspector.inspectThrowable(th);
             outputHandler.warn("Error reading index file", th);
-<<<<<<<
             indexIterator.close();
             return false;
-=======
-            nextIndexKey = null;
-            nextPartitionPositionFromIndex = dataFile.length();
-            if (indexFile != null)
-                indexFile.seek(indexFile.length());
->>>>>>>
         }
     }
 
@@ -469,25 +391,9 @@
 
     private void seekToNextPartition()
     {
-<<<<<<<
         long nextRowPositionFromIndex = indexIterator.isExhausted()
                                         ? dataFile.length()
                                         : indexIterator.dataPosition();
-=======
-        while(nextPartitionPositionFromIndex < dataFile.length())
-        {
-            try
-            {
-                dataFile.seek(nextPartitionPositionFromIndex);
-                return;
-            }
-            catch (Throwable th)
-            {
-                throwIfFatal(th);
-                outputHandler.warn(String.format("Failed to seek to next partition position %d", nextPartitionPositionFromIndex), th);
-                badPartitions++;
-            }
->>>>>>>
 
         try
         {
@@ -497,7 +403,7 @@
         {
             throwIfFatal(th);
             outputHandler.warn(String.format("Failed to seek to next row position %d", nextRowPositionFromIndex), th);
-            badRows++;
+            badPartitions++;
         }
     }
 
