--- a/src/java/org/apache/cassandra/service/CacheService.java
+++ b/src/java/org/apache/cassandra/service/CacheService.java
@@ -23,11 +23,8 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
-<<<<<<<
 import java.util.Map;
-=======
 import java.util.Objects;
->>>>>>>
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
@@ -427,7 +424,7 @@
         // For column families with many SSTables the linear nature of getSSTables slowed down KeyCache loading
         // by orders of magnitude. So we cache the sstables once and rely on cleanupAfterDeserialize to cleanup any
         // cached state we may have accumulated during the load.
-        Map<Pair<String, String>, Map<Integer, SSTableReader>> cachedSSTableReaders = new ConcurrentHashMap<>();
+        Map<Pair<String, String>, Map<SSTableUniqueIdentifier, SSTableReader>> cachedSSTableReaders = new ConcurrentHashMap<>();
 
         public void serialize(KeyCacheKey key, DataOutputPlus out, ColumnFamilyStore cfs) throws IOException
         {
@@ -466,12 +463,11 @@
                                   : new SequenceBasedSSTableUniqueIdentifier(generation); // Backwards compatibility for "int based generation sstables"
 
             input.readBoolean(); // backwards compatibility for "promoted indexes" boolean
-<<<<<<<
             SSTableReader reader = null;
             if (!skipEntry)
             {
                 Pair<String, String> qualifiedName = Pair.create(cfs.metadata.keyspace, cfs.metadata.name);
-                Map<Integer, SSTableReader> generationToSSTableReader = cachedSSTableReaders.get(qualifiedName);
+                Map<SSTableUniqueIdentifier, SSTableReader> generationToSSTableReader = cachedSSTableReaders.get(qualifiedName);
                 if (generationToSSTableReader == null)
                 {
                     generationToSSTableReader = new HashMap<>(cfs.getLiveSSTables().size());
@@ -486,10 +482,6 @@
             }
 
             if (skipEntry || reader == null)
-=======
-            SSTableReader reader;
-            if (cfs == null || !cfs.isKeyCacheEnabled() || (reader = findDesc(generationId, cfs.getSSTables(SSTableSet.CANONICAL))) == null)
->>>>>>>
             {
                 // The sstable doesn't exist anymore, so we can't be sure of the exact version and assume its the current version. The only case where we'll be
                 // wrong is during upgrade, in which case we fail at deserialization. This is not a huge deal however since 1) this is unlikely enough that
@@ -504,7 +496,11 @@
             return Futures.immediateFuture(Pair.create(new KeyCacheKey(cfs.metadata(), reader.descriptor, key), entry));
         }
 
-<<<<<<<
+        public void cleanupAfterDeserialize()
+        {
+            cachedSSTableReaders.clear();
+        }
+
         private SSTableReader findDesc(SSTableUniqueIdentifier generation, Iterable<SSTableReader> collection)
         {
             for (SSTableReader sstable : collection)
@@ -513,11 +509,6 @@
                     return sstable;
             }
             return null;
-=======
-        public void cleanupAfterDeserialize()
-        {
-            cachedSSTableReaders.clear();
->>>>>>>
         }
     }
 }
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexDeletionsTest.java
@@ -19,10 +19,7 @@
 package org.apache.cassandra.cql3;
 
 import java.util.Arrays;
-<<<<<<<
-=======
-import java.util.Collection;
->>>>>>>
+import java.util.Comparator;
 import java.util.Comparator;
 import java.util.List;
 import java.util.stream.Collectors;
@@ -121,13 +118,8 @@
             ColumnFamilyStore cfs = ks.getColumnFamilyStore(mv);
             List<String> sstables = cfs.getLiveSSTables()
                                        .stream()
-<<<<<<<
                                        .sorted(Comparator.comparing(s -> s.descriptor.generation))
-                                       .map(s -> s.getFilename())
-=======
-                                       .sorted(Comparator.comparingInt(s -> s.descriptor.generation))
                                        .map(SSTableReader::getFilename)
->>>>>>>
                                        .collect(Collectors.toList());
             String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(3), sstables.get(4)));
             CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
@@ -109,85 +109,7 @@
         if (flush)
             FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from %s"), row(1, 1, null, 1));
-<<<<<<<
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv), row(1, 1, null, 1));
-=======
-        assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from mv"), row(1, 1, null, 1));
-    }
-
-    @Test
-    public void testCellTombstoneAndShadowableTombstonesWithFlush() throws Throwable
-    {
-        testCellTombstoneAndShadowableTombstones(true);
-    }
-
-    @Test
-    public void testCellTombstoneAndShadowableTombstonesWithoutFlush() throws Throwable
-    {
-        testCellTombstoneAndShadowableTombstones(false);
-    }
-
-    private void testCellTombstoneAndShadowableTombstones(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // sstable 1, Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
-        // sstable 2
-        updateView("UPdate %s using timestamp 2 set v2 = null where p = 3", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3),
-                                row(null, null));
-        // sstable 3
-        updateView("UPdate %s using timestamp 3 set v1 = 2 where p = 3", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
-        // sstable 4
-        updateView("UPdate %s using timestamp 4 set v1 = 1 where p = 3", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-
-        if (flush)
-        {
-            // compact sstable 2 and 3;
-            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
-            List<String> sstables = cfs.getLiveSSTables()
-                                       .stream()
-                                       .sorted(Comparator.comparing(s -> s.descriptor.generation))
-                                       .map(s -> s.getFilename())
-                                       .collect(Collectors.toList());
-            String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(2)));
-            CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
-        }
-        // cell-tombstone in sstable 4 is not compacted away, because the shadowable tombstone is shadowed by new row.
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, null, null));
->>>>>>>
     }
 
     @Test
--- a/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -37,11 +37,8 @@
 import org.json.simple.JSONObject;
 import org.json.simple.parser.JSONParser;
 
-<<<<<<<
 import static org.apache.cassandra.db.ColumnFamilyStore.FlushReason.UNIT_TESTS;
-=======
 import static org.assertj.core.api.Assertions.assertThat;
->>>>>>>
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
--- a/test/unit/org/apache/cassandra/db/DirectoriesTest.java
+++ b/test/unit/org/apache/cassandra/db/DirectoriesTest.java
@@ -52,14 +52,11 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
-<<<<<<<
-=======
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.schema.Indexes;
 import org.apache.cassandra.schema.SchemaConstants;
 import org.apache.cassandra.schema.SchemaKeyspaceTables;
 import org.apache.cassandra.schema.TableMetadata;
->>>>>>>
 import org.apache.cassandra.auth.AuthKeyspace;
 import org.apache.cassandra.config.Config.DiskFailurePolicy;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -78,10 +75,6 @@
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.schema.IndexMetadata;
-import org.apache.cassandra.schema.Indexes;
-import org.apache.cassandra.schema.SchemaConstants;
-import org.apache.cassandra.schema.SchemaKeyspace;
-import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.service.DefaultFSErrorHandler;
 import org.apache.cassandra.utils.JVMStabilityInspector;
 
--- a/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
+++ b/test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
@@ -81,11 +81,8 @@
 import org.apache.cassandra.utils.NonThrowingCloseable;
 import org.mockito.Mockito;
 
-<<<<<<<
 import static org.apache.cassandra.db.ColumnFamilyStore.FlushReason.UNIT_TESTS;
-=======
 import static org.assertj.core.api.Assertions.assertThat;
->>>>>>>
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
--- a/test/unit/org/apache/cassandra/index/CustomIndexTest.java
+++ b/test/unit/org/apache/cassandra/index/CustomIndexTest.java
@@ -65,11 +65,8 @@
 import org.apache.cassandra.utils.concurrent.OpOrder;
 
 import static org.apache.cassandra.cql3.statements.schema.IndexTarget.CUSTOM_INDEX_OPTION_NAME;
-<<<<<<<
 import static org.apache.cassandra.db.ColumnFamilyStore.FlushReason.UNIT_TESTS;
-=======
 import static org.assertj.core.api.Assertions.assertThat;
->>>>>>>
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
diff --git a/src/java/org/apache/cassandra/service/CacheService.java b/src/java/org/apache/cassandra/service/CacheService.java
index 0819b18f7e..21cc0a5cff 100644
--- a/src/java/org/apache/cassandra/service/CacheService.java
+++ b/src/java/org/apache/cassandra/service/CacheService.java
@@ -424,7 +424,7 @@ public class CacheService implements CacheServiceMBean
         // For column families with many SSTables the linear nature of getSSTables slowed down KeyCache loading
         // by orders of magnitude. So we cache the sstables once and rely on cleanupAfterDeserialize to cleanup any
         // cached state we may have accumulated during the load.
-        Map<Pair<String, String>, Map<Integer, SSTableReader>> cachedSSTableReaders = new ConcurrentHashMap<>();
+        Map<Pair<String, String>, Map<SSTableUniqueIdentifier, SSTableReader>> cachedSSTableReaders = new ConcurrentHashMap<>();
 
         public void serialize(KeyCacheKey key, DataOutputPlus out, ColumnFamilyStore cfs) throws IOException
         {
@@ -467,7 +467,7 @@ public class CacheService implements CacheServiceMBean
             if (!skipEntry)
             {
                 Pair<String, String> qualifiedName = Pair.create(cfs.metadata.keyspace, cfs.metadata.name);
-                Map<Integer, SSTableReader> generationToSSTableReader = cachedSSTableReaders.get(qualifiedName);
+                Map<SSTableUniqueIdentifier, SSTableReader> generationToSSTableReader = cachedSSTableReaders.get(qualifiedName);
                 if (generationToSSTableReader == null)
                 {
                     generationToSSTableReader = new HashMap<>(cfs.getLiveSSTables().size());
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
index e6c599b405..5fd4ed3e3b 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
@@ -112,80 +112,6 @@ public class ViewComplexTest extends ViewComplexTester
         assertRowsIgnoringOrder(execute("SELECT p1, p2, v1, v2 from " + mv), row(1, 1, null, 1));
     }
 
-    @Test
-    public void testCellTombstoneAndShadowableTombstonesWithFlush() throws Throwable
-    {
-        testCellTombstoneAndShadowableTombstones(true);
-    }
-
-    @Test
-    public void testCellTombstoneAndShadowableTombstonesWithoutFlush() throws Throwable
-    {
-        testCellTombstoneAndShadowableTombstones(false);
-    }
-
-    private void testCellTombstoneAndShadowableTombstones(boolean flush) throws Throwable
-    {
-        createTable("create table %s (p int primary key, v1 int, v2 int)");
-
-        execute("USE " + keyspace());
-        executeNet(version, "USE " + keyspace());
-        Keyspace ks = Keyspace.open(keyspace());
-
-        createView("mv",
-                   "create materialized view %s as select * from %%s where p is not null and v1 is not null primary key (v1, p);",
-                   version,
-                   this,
-                   views);
-        ks.getColumnFamilyStore("mv").disableAutoCompaction();
-
-        // sstable 1, Set initial values TS=1
-        updateView("Insert into %s (p, v1, v2) values (3, 1, 3) using timestamp 1;", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3), row(3, 1L));
-        // sstable 2
-        updateView("UPdate %s using timestamp 2 set v2 = null where p = 3", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v2, WRITETIME(v2) from mv WHERE v1 = ? AND p = ?", 1, 3),
-                                row(null, null));
-        // sstable 3
-        updateView("UPdate %s using timestamp 3 set v1 = 2 where p = 3", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(2, 3, null, null));
-        // sstable 4
-        updateView("UPdate %s using timestamp 4 set v1 = 1 where p = 3", version, this);
-
-        if (flush)
-            FBUtilities.waitOnFutures(ks.flush(UNIT_TESTS));
-
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-
-        if (flush)
-        {
-            // compact sstable 2 and 3;
-            ColumnFamilyStore cfs = ks.getColumnFamilyStore("mv");
-            List<String> sstables = cfs.getLiveSSTables()
-                                       .stream()
-                                       .sorted(Comparator.comparing(s -> s.descriptor.generation))
-                                       .map(s -> s.getFilename())
-                                       .collect(Collectors.toList());
-            String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(2)));
-            CompactionManager.instance.forceUserDefinedCompaction(dataFiles);
-        }
-        // cell-tombstone in sstable 4 is not compacted away, because the shadowable tombstone is shadowed by new row.
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv"), row(1, 3, null, null));
-        assertRowsIgnoringOrder(execute("SELECT v1, p, v2, WRITETIME(v2) from mv limit 1"), row(1, 3, null, null));
-    }
-
     @Test
     public void testMVWithDifferentColumnsWithFlush() throws Throwable
     {
diff --git a/test/unit/org/apache/cassandra/cql3/ViewComplexTombstoneTest.java b/test/unit/org/apache/cassandra/cql3/ViewComplexTombstoneTest.java
index d8ff686d4d..20e7391bf6 100644
--- a/test/unit/org/apache/cassandra/cql3/ViewComplexTombstoneTest.java
+++ b/test/unit/org/apache/cassandra/cql3/ViewComplexTombstoneTest.java
@@ -105,7 +105,7 @@ public class ViewComplexTombstoneTest extends ViewComplexTester
             ColumnFamilyStore cfs = ks.getColumnFamilyStore(mv);
             List<String> sstables = cfs.getLiveSSTables()
                                        .stream()
-                                       .sorted(Comparator.comparingInt(s -> s.descriptor.generation))
+                                       .sorted(Comparator.comparing(s -> s.descriptor.generation))
                                        .map(SSTableReader::getFilename)
                                        .collect(Collectors.toList());
             String dataFiles = String.join(",", Arrays.asList(sstables.get(1), sstables.get(2)));
diff --git a/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java b/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
index 3354ed0eea..5c3bc916ec 100644
--- a/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
+++ b/test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
@@ -45,6 +45,7 @@ import org.apache.cassandra.db.SerializationHeader;
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
+import org.apache.cassandra.io.sstable.SequenceBasedSSTableUniqueIdentifier;
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
